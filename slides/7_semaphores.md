---
marp: true
paginate: true
theme: 'dauphine'
---

<!-- _class: lead -->

<!-- _header: L3 Informatique ‚Ä¢ 2022-2023 ‚Ä¢ Syst√®mes d'exploitation -->

# Concurrence :
# condition variables et s√©maphores

<br>

Thibaud Martinez
thibaud.martinez@dauphine.psl.eu

<!-- _footer: ![width:300](../slides/images/logo-dauphine.png) -->

---

Cette pr√©sentation couvre les chapitres [30](https://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf), [31](https://pages.cs.wisc.edu/~remzi/OSTEP/threads-sema.pdf) et [32](https://pages.cs.wisc.edu/~remzi/OSTEP/threads-bugs.pdf) de Operating Systems: Three Easy Pieces.

<br>

Les diapositives sont librement adapt√©es de diapositives de _Youjip Won (Hanyang University)_.

---

## Comment un thread parent peut v√©rifier qu'un thread enfant a fini de r√©aliser une action ?

```c
void *child(void *arg) {
    // Action √† r√©aliser.
    // Comment indiquer au parent que l'action est r√©alis√©e ?
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t c;
    Pthread_create(&c, NULL, child, NULL);
    // Comment attendre que l'enfant ait r√©alis√©e l'action ?
    return 0;
}
```

---

## Une approche bas√©e sur l'attente active

```c
int done = 0;

void *child(void *arg) {
    // Action √† r√©aliser.
    done = 1;
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t c;
    Pthread_create(&c, NULL, child, NULL);
    while (done == 0)
        ; // spin
    return 0;
}
```

Cette m√©thode est inefficace : le parent **gaspille du temps CPU** en attendant l'enfant.

---

## Condition variable

Il existe de nombreux cas o√π un thread souhaite **v√©rifier si une condition est vraie** avant de **poursuivre son ex√©cution**. 

<br>

La primitive de synchronisation _**condition variable**_ permet cela, √† travers deux op√©rations:

* **Attente de la condition** _(wait)_ : les threads peuvent se placer dans une file d'attente lorsqu'un √©tat d'ex√©cution n'est pas atteint.

* **Signalisation de la condition** _(signal)_ : un autre thread, lorsqu'il change d'√©tat, peut r√©veiller l'un des threads en attente et lui permettre de continuer.

---

<style scoped>
pre {
   font-size: 0.8em;
}

p {
    font-size: 0.9em;
}
</style>

## Utilisation des `pthread_cond_t`

### D√©claration et initialisation

```c
#include <pthread.h>

pthread_cond_t c;               // D√©claration de la condition variable.
c = PTHREAD_COND_INITIALIZER;   // Une initialisation est n√©cessaire.
```

### Op√©rations

```c
pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m);
pthread_cond_signal(pthread_cond_t *c);
```

* L'appel `wait()` prend un mutex en param√®tre.
* L'appel `wait()` lib√®re le verrou et met le thread appelant en sommeil.
* Lorsque le thread se r√©veille, il doit r√©acqu√©rir le verrou.

---

## Utilisation d'une condition variable pour que le parent attende l'enfant

```c
int done = 0;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t c = PTHREAD_COND_INITIALIZER;

void thr_exit() {
    Pthread_mutex_lock(&m);
    done = 1;
    Pthread_cond_signal(&c);
    Pthread_mutex_unlock(&m);
}

void *child(void *arg) {
    thr_exit();
    return NULL;
}
```

---

```c
void thr_join() {
    Pthread_mutex_lock(&m);
    while (done == 0)
        Pthread_cond_wait(&c, &m);
    Pthread_mutex_unlock(&m);
}

int main(int argc, char *argv[]) {
    pthread_t p;
    Pthread_create(&p, NULL, child, NULL);
    thr_join();
    return 0;
}
```

---

## L'importance de la variable d'√©tat `done`

```c
void thr_exit() {
    Pthread_mutex_lock(&m);
    Pthread_cond_signal(&c);
    Pthread_mutex_unlock(&m);
}

void thr_join() {
    Pthread_mutex_lock(&m);
    Pthread_cond_wait(&c, &m);
    Pthread_mutex_unlock(&m);
}
```

Imaginons le cas o√π l'enfant s'ex√©cute imm√©diatement.
* L'enfant √©mettra un signal, mais il n'y a pas de thread endormi attendant la condition.
* Lorsque le parent s'ex√©cute, il appelle wait et reste bloqu√©, aucun thread ne le r√©veillera jamais.

---

<style scoped>
pre {
   font-size: 0.8em;
}

p, li {
    font-size: 0.8em;
}
</style>

## L'importance du mutex

```c
void thr_exit() {
    done = 1;
    Pthread_cond_signal(&c);
}

void thr_join() {
    while (done == 0)
        Pthread_cond_wait(&c);
}
```

Il s'agit ici d'une _race condition_ subtile.
* Le parent appelle `thr_join()`.
* Le parent v√©rifie la valeur de `done`. Celle-ci est de `0` et le parent essaie de s'endormir.
* Juste avant d'appeler `wait()` pour s'endormir, le parent est interrompu et l'enfant s'ex√©cute.
* L'enfant change la variable d'√©tat `done` en `1` et √©met un signal. Mais aucun thread n'est en attente et donc aucun thread n'est r√©veill√©.
* Lorsque le parent s'ex√©cute √† nouveau, il s'endort pour toujours.

---

## S√©maphore

Il s'agit d'une primitive de synchronisation contentant une **valeur enti√®re**. 
&nbsp;&nbsp;&nbsp;&nbsp;_‚Üí invent√© par Edsger Dijkstra._

La valeur du s√©maphore est manipul√©e gr√¢ce √† deux op√©rations :`sem_wait()` et `sem_post()`.

### Initialisation

```c
#include <semaphore.h>
sem_t s;
sem_init(&s, 0, 1); // initialise s √† la valeur 1
```
‚Üí Le deuxi√®me argument, `0`, indique que le s√©maphore est partag√© entre les threads d'un m√™me processus.

---

### Op√©rations

```c
int sem_wait(sem_t *s)
```

D√©cr√©mente la valeur du s√©maphore `s` de `1` et met le thread en attente si la valeur du s√©maphore `s` est n√©gative.

‚Üí Lorsqu'elle est n√©gative, la valeur du s√©maphore est √©gale au **nombre de threads en attente**.

<br>

```c
int sem_post(sem_t *s) 
```

Incr√©mente la valeur du s√©maphore `s` de `1`. S'il y a un ou plusieurs threads en attente, un des threads est r√©veill√©.

---

_√Ä quelle valeur le s√©maphore doit-il √™tre initialis√© pour √™tre utilis√© comme un verrou ?_

<br>

```c
sem_t m; 
sem_init(&m, 0, X); // quelle devrait √™tre la valeur de X ? 
```

---

## S√©maphores binaires (verrous)

Un s√©maphore initialis√© avec une valeur de `1` se comporte comme un verrou.

```c
sem_t m; 
sem_init(&m, 0, 1); 

sem_wait(&m); 
// section critique 
sem_post(&m); 
```

---

## Deux threads utilisant un s√©maphore binaire

![center](./images/semaphore-two-threads.png)

---

<style scoped>
p, li {
    font-size: 0.9em;
}
</style>

## Le probl√®me du producteur / consommateur (_bounded buffer_)

<br>

<div class="columns">
<div>

**Producteur**
* Produit des √©l√©ments de donn√©es.
* Souhaite placer ces donn√©es dans une m√©moire tampon.

**Consommateur**
* R√©cup√®re les donn√©es dans la m√©moire tampon et les consomme d'une mani√®re ou d'une autre.

</div>
<div>

![center height:400px](./images/producer-consumer.drawio.png)

</div>
</div>

---

_Exemple : Serveur web multithreads_
* Un producteur place les requ√™tes HTTP dans une file d'attente.
* Les consommateurs extraient les requ√™tes de cette file d'attente et les traitent.

### Contraintes

* Le **producteur** doit attendre qu'il y ait des emplacements **disponibles** dans la m√©moire tampon pour les remplir.

* Le **consommateur** doit attendre que des √©l√©ments de donn√©es aient √©t√© **plac√©s** dans le tampon pour les consommer.

---

```c
int buffer[MAX]; 
int fill = 0; 
int use = 0; 
 
// Utilis√© par le producteur pour placer les donn√©es dans le tampon. 
void put(int value) { 
    buffer[fill] = value;       // ligne f1 
    fill = (fill + 1) % MAX; 	// ligne f2 
} 

// Utilis√© par le consommateur pour r√©cup√©rer les donn√©es du tampon.
int get() { 
    int tmp = buffer[use]; 	// ligne g1 
    use = (use + 1) % MAX; 	// ligne g2 
    return tmp;
}
```

---

```c
sem_t empty; 
sem_t full; 
 
void *producer(void *arg) { 
    int i; 
    for (i = 0; i < loops; i++) { 
        sem_wait(&empty);       // ligne p1 
        put(i);                 // ligne p2 
        sem_post(&full);        // ligne p3 
    } 
} 
 
void *consumer(void *arg) { 
    int i, tmp = 0; 
    while (tmp != -1) { 
        sem_wait(&full);        // ligne c1 
        tmp = get();            // ligne c2 
        sem_post(&empty);       // ligne c3 
    } 
} 
```

---

```c
  int main(int argc, char *argv[]) {
      // ...
      sem_init(&empty, 0, MAX); // MAX buffers sont vides au d√©but 
      sem_init(&full, 0, 0); 	// ‚Ä¶ et 0 sont pleins
      // ...
  }

```

---

# üí•

Imaginons que `MAX` soit sup√©rieur √† `1`.
* S'il y a plusieurs producteurs, une _race condition_ peut se produire √† la ligne f1.
* Cela signifie que les anciennes donn√©es sont **√©cras√©es**.

<br>

Nous avons oubli√© l'**exclusion mutuelle** !

‚Üí Le remplissage d'un tampon et l'incr√©mentation de l'index dans le tampon constitue une section critique.

---

## Une solution : mettre en ≈ìuvre l'exclusion mutuelle

```c
sem_t empty; 
sem_t full; 
sem_t mutex; 
 
void *producer(void *arg) { 
    int i; 
    for (i = 0; i < loops; i++) { 
        sem_wait(&mutex);   // ligne p0 (NOUVELLE LIGNE) 
        sem_wait(&empty);   // ligne p1 
        put(i);             // ligne p2 
        sem_post(&full);    // ligne p3 
        sem_post(&mutex);   // ligne p4 (NOUVELLE LIGNE) 
    } 
}
```

---

```c
void *consumer(void *arg) { 
    int i; 
    for (i = 0; i < loops; i++) { 
        sem_wait(&mutex);   // ligne c0 (NOUVELLE LIGNE) 
        sem_wait(&full);    // ligne c1 
        int tmp = get();    // ligne c2 
        sem_post(&empty);   // ligne c3 
        sem_post(&mutex);   // ligne c4 (NOUVELLE LIGNE) 
        printf("%d\n", tmp); 
    } 
} 
```

---

# üí•

Imaginons deux threads : un producteur et un consommateur.
* Le consommateur acquiert le mutex (ligne c0).
* Le consommateur appelle `sem_wait()` sur le s√©maphore `full` (ligne c1).
* Le consommateur est bloqu√© et c√®de le processur.
* Le consommateur d√©tient toujours le mutex !
* Le producteur appelle `sem_wait()` sur le s√©maphore binaire du mutex (ligne p0).
* Le producteur est maintenant bloqu√© et attend lui aussi, ce qui constitue un interblocage classique (_deadlock_).

---

## Finalement, une solution qui fonctionne

```c
sem_t empty; 
sem_t full; 
sem_t mutex; 
 
void *producer(void *arg) { 
    int i; 
    for (i = 0; i < loops; i++) { 
        sem_wait(&empty);   // ligne p1
        sem_wait(&mutex);   // ligne p1.5 (MUTEX D√âPLAC√â ICI...) 
        put(i);             // ligne p2 
        sem_post(&mutex);   // ligne p2.5 (... ET ICI) 
        sem_post(&full);    // ligne p3
    } 
} 
```

---

```c
void *consumer(void *arg) { 
    int i; 
    for (i = 0; i < loops; i++) { 
        sem_wait(&full);        // ligne c1
        sem_wait(&mutex);       // ligne c1.5 (MUTEX D√âPLAC√â ICI...) 
        int tmp = get();        // ligne c2 
        sem_post(&mutex);       // ligne c2.5 (... ET ICI) 
        sem_post(&empty);       // ligne c3
        printf(‚Äú%d\n‚Äù, tmp);
    }
}
 
int main(int argc, char *argv[]) {
 	// ...
 	sem_init(&empty, 0, MAX);
 	sem_init(&full, 0, 0);
 	sem_init(&mutex, 0, 1);   // mutex=1 car c'est un verrou
 	// ...
}
```

---

## Comment impl√©menter un s√©maphore ?

```c
typedef struct __Zem_t { 
    int value; 
    pthread_cond_t cond; 
    pthread_mutex_t lock; 
} Zem_t; 
 
// un seul thread peut appeler cette fonction
void Zem_init(Zem_t *s, int value) { 
    s->value = value; 
    Cond_init(&s->cond); 
    Mutex_init(&s->lock); 
} 
 
void Zem_wait(Zem_t *s) { 
    Mutex_lock(&s->lock); 
    while (s->value <= 0) 
        Cond_wait(&s->cond, &s->lock); 
    s->value--; 
    Mutex_unlock(&s->lock); 
}
```

---

```c
void Zem_post(Zem_t *s) { 
    Mutex_lock(&s->lock); 
    s->value++; 
    Cond_signal(&s->cond); 
    Mutex_unlock(&s->lock); 
} 
```

<br>

Contrairement au s√©maphores purs tels que d√©finis par Dijkstra, la valeur de notre Zemaphore ne sera **jamais inf√©rieure √† `0`**, et donc ne refl√®tera pas le **nombre de threads en attente** lorsqu'elle est n√©gative.

‚Üí Ce comportement est plus facile √† mettre en ≈ìuvre et correspond √† l'impl√©mentation actuelle de Linux.

---

<style scoped>
p {
    font-size: 0.9em;
}

table {
    font-size: 0.8em;
}
</style>

## Probl√®mes de concurrence communs

Les probl√®mes de concurrence sont souvent **sources de bugs** dans les programmes.

Une √©tude de _Lu et al._ analyse 4 applications _open-source_ populaires pour identifier quels sont les bugs qu'on rencontre le plus couramment.


<center>

| Application | Type d'application | Autre que deadlocks | Deadlocks |
|-------------|--------------------|--------------------|----------|
| MYSQL       | Base de donn√©es    | 14                 | 9        |
| Apache      | Serveur web        | 13                 | 4        |
| Firefox     | Navigateur web     | 41                 | 16       |
| Open Office | Suite bureautique  | 6                  | 2        |
| **Total**   |                    | **74**             | **31**   |
</center>

<!-- _footer: Lu, S., Park, S., Seo, E. and Zhou, Y., 2008, March. Learning from mistakes: a comprehensive study on real world concurrency bug characteristics. <br> ASPLOS ‚Äô08, March 2008, Seattle, Washington. -->

---

<style scoped>
p, li {
    font-size: 0.9em;
}
</style>

## Interblocages (_deadlocks_)

<br>

<div class="columns">
<div>

```
Thread 1:       Thread 2:
lock(L1);       lock(L2);
lock(L2);       lock(L1);
```

<br>

Pr√©sence d'un cycle :
* Thread 1 d√©tient le verrou L1 et en attend un autre, L2.
* Thread 2 d√©tient le verrou L2 et attend que L1 soit lib√©r√©.

</div>
<div>

![center height:350px](./images/deadlock.drawio.png)

</div>
</div>


---

## Bugs dus √† la violation de l'atomicit√©

Une r√©gion de code est cens√©e √™tre atomique, mais l'atomicit√© n'est pas respect√©e pendant l'ex√©cution.

_Exemple simple trouv√© dans MySQL :_ deux threads diff√©rents acc√®dent au champ `proc_info` dans la structure `thd`.

```c
// Thread 1
if (thd->proc_info){
    ...
    fputs(thd->proc_info, ...);
    ...
}

// Thread 2
thd->proc_info = NULL; 
```

---

**Solution** : ajouter des **verrous** autour des r√©f√©rences aux variables partag√©es.

```c
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;


// Thread 1
pthread_mutex_lock(&lock);
if (thd->proc_info){
    ...
    fputs(thd->proc_info, ...);
    ...
}
pthread_mutex_unlock(&lock);

// Thread 2
pthread_mutex_lock(&lock);
thd->proc_info = NULL; 
pthread_mutex_unlock(&lock);
```

---

## Bugs dus au non-respect de l'ordre d'ex√©cution

L'ordre souhait√© entre deux acc√®s √† la m√©moire est invers√©.

‚Üí **A** devrait toujours √™tre ex√©cut√© avant **B**, mais l'ordre n'est pas respect√© pendant l'ex√©cution.

_Exemple :_ le code de Thread 2 suppose que la variable `mThread` a d√©j√† √©t√© initialis√©e (et n'est pas `NULL`).

```c
// Thread 1
void init(){
    mThread = PR_CreateThread(mMain, ...); 
}
 
// Thread 2
void mMain(‚Ä¶){
    mState = mThread->State
}
```

---

**Solution :** garantir l'ordre d'ex√©cution en utilisant des **conditions variables**.

```c
pthread_mutex_t mtLock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t mtCond = PTHREAD_COND_INITIALIZER;
int mtInit = 0;
 
// Thread 1
void init(){
    mThread = PR_CreateThread(mMain,‚Ä¶);

    // signale que le thread a √©t√© cr√©√©.
    pthread_mutex_lock(&mtLock);
    mtInit = 1;
    pthread_cond_signal(&mtCond);
    pthread_mutex_unlock(&mtLock);
}
```

---

```c
// Thread 2
void mMain(‚Ä¶){
    // attendre que mThread soit initialis√©
    pthread_mutex_lock(&mtLock);
    while(mtInit == 0)
        pthread_cond_wait(&mtCond, &mtLock);
    pthread_mutex_unlock(&mtLock);

    mState = mThread->State;
}
```

---

## Pour aller plus loin

* [The Little Book of Semaphores, Allen B. Downey](https://greenteapress.com/wp/semaphores/)

* [Dijkstra, E.W., 2002. Cooperating sequential processes](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD01xx/EWD123.html)